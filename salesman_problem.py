# -*- coding: utf-8 -*-
"""salesman_problem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ueg1SzZStqN5q6G-CNf8xWk_cuVeTcSR
"""

import itertools
import math


def distance(point1, point2):
    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)


def tsp_brute_force(points):
    n = len(points)
    shortest_path = None
    min_distance = float('inf')

    for permutation in itertools.permutations(range(1, n)):
        path = [0] + list(permutation)
        dist = sum(distance(points[path[i]], points[path[i+1]]) for i in range(n-1))
        dist += distance(points[path[-1]], points[0])
        if dist < min_distance:
            min_distance = dist
            shortest_path = path

    return shortest_path, min_distance


def tsp_nearest_neighbor(points):
    n = len(points)
    visited = [False] * n
    path = [0]
    visited[0] = True
    total_distance = 0

    for _ in range(n - 1):
        last = path[-1]
        nearest = None
        min_dist = float('inf')

        for i in range(n):
            if not visited[i] and distance(points[last], points[i]) < min_dist:
                nearest = i
                min_dist = distance(points[last], points[i])

        path.append(nearest)
        visited[nearest] = True
        total_distance += min_dist

    total_distance += distance(points[path[-1]], points[0])
    return path, total_distance


def calculate_error(optimal, approx):
    return ((approx - optimal) / optimal) * 100


points = [(0, 0), (1, 3), (4, 3), (6, 1)]
optimal_path, optimal_distance = tsp_brute_force(points)
approx_path, approx_distance = tsp_nearest_neighbor(points)
error = calculate_error(optimal_distance, approx_distance)

print("Optimal Path (Brute Force):", optimal_path)
print("Optimal Distance:", optimal_distance)
print("Approximation Path (Nearest Neighbor):", approx_path)
print("Approximation Distance:", approx_distance)
print("Error in Approximation (%):", error)

