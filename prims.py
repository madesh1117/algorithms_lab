# -*- coding: utf-8 -*-
"""prim.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QLjqJjNnHU9vEgcjwBxvC7flYO2SyOFy
"""

import heapq

def prim(graph, start):
    mst = []  # To store the edges of the Minimum Spanning Tree
    visited = set()  # Track visited nodes
    pq = []  # Priority queue to store edges (cost, node1, node2)
    visited.add(start)

    # Add all edges from the start node to the priority queue
    for neighbor, weight in graph[start]:
        heapq.heappush(pq, (weight, start, neighbor))

    while pq:
        cost, node1, node2 = heapq.heappop(pq)
        if node2 not in visited:
            visited.add(node2)
            mst.append((node1, node2, cost))

            # Add all edges from the current node to the priority queue
            for neighbor, weight in graph[node2]:
                if neighbor not in visited:
                    heapq.heappush(pq, (weight, node2, neighbor))

    return mst

# Example graph represented as adjacency list
graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('A', 1), ('C', 2), ('D', 6)],
    'C': [('A', 4), ('B', 2), ('D', 3)],
    'D': [('B', 6), ('C', 3)],
}

start_vertex = 'A'
mst = prim(graph, start_vertex)

print("Minimum Cost Spanning Tree:")
for edge in mst:
    print(f"{edge[0]} - {edge[1]} (Cost: {edge[2]})")

